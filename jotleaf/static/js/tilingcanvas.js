// Generated by CoffeeScript 1.4.0
var CANVAS_DEBUG, SCROLLPOS_DEBUG, Scroller, Tile, TilingCanvas,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

CANVAS_DEBUG = false;

SCROLLPOS_DEBUG = false;

Tile = (function(_super) {

  __extends(Tile, _super);

  function Tile() {
    this.render = __bind(this.render, this);

    this.addItem = __bind(this.addItem, this);
    return Tile.__super__.constructor.apply(this, arguments);
  }

  Tile.prototype.className = 'tilingcanvas-tile';

  Tile.prototype.addItem = function(pixelX, pixelY, el) {
    el = $(el);
    return $(el).appendTo(this.$el).css({
      left: pixelX,
      top: pixelY,
      position: 'absolute',
      zIndex: (parseInt(el.css('zIndex'), 10) || 2) + 100
    });
  };

  Tile.prototype.render = function() {
    var tileX, tileY;
    if (CANVAS_DEBUG) {
      tileX = this.$el.data('tileX');
      tileY = this.$el.data('tileY');
      this.$el.text("(" + tileX + ", " + tileY + ")");
      this.$el.addClass('debug');
    }
    return this;
  };

  return Tile;

})(Backbone.View);

Scroller = (function() {

  Scroller.prototype.SCROLL_PX_PER_SECOND = 5000;

  Scroller.prototype.SCROLL_FREQUENCY = 60;

  Scroller.prototype.ACCELERATION_TIME = 1000;

  Scroller.prototype.EXACT = 0;

  Scroller.prototype.FIRST_OBTUSE = 1;

  function Scroller(getCurrentPosition, moveContent, path, strategy) {
    var DECEL_DIST, delay, start_idx;
    this.getCurrentPosition = getCurrentPosition;
    this.moveContent = moveContent;
    this.path = path;
    if (strategy == null) {
      strategy = 0;
    }
    this.getSpeed = __bind(this.getSpeed, this);

    this.pathLength = __bind(this.pathLength, this);

    this.move = __bind(this.move, this);

    assert(this.path.length);
    this.done = false;
    this.ACCELERATION = this.SCROLL_PX_PER_SECOND * 1000 / this.ACCELERATION_TIME;
    DECEL_DIST = 1 / 2 * this.ACCELERATION * (this.ACCELERATION_TIME / 1000) * (this.ACCELERATION_TIME / 1000);
    this.DECEL_DIST = DECEL_DIST / 16;
    this.MIN_SPEED = 500;
    switch (strategy) {
      case this.EXACT:
        start_idx = 0;
        break;
      case this.FIRST_OBTUSE:
        start_idx = Vec.firstObtuse(this.getCurrentPosition(), this.path);
        break;
      default:
        throw new Error("Unknown scroll strategy");
    }
    this.path = this.path.slice(start_idx);
    this.expectedDistance = this.pathLength(this.path);
    this.target = this.path.shift();
    this.distanceMoved = 0;
    this.startTime = new Date().getTime();
    delay = Math.ceil(1000 / this.SCROLL_FREQUENCY);
    this._timer = setInterval(this.move, delay);
  }

  Scroller.prototype.move = function() {
    var centerX, centerY, distToMove, distanceLeft, x, xDiff, xMove, y, yDiff, yMove, _ref, _ref1;
    _ref = this.target, x = _ref[0], y = _ref[1];
    _ref1 = this.getCurrentPosition(), centerX = _ref1[0], centerY = _ref1[1];
    xDiff = centerX - x;
    yDiff = centerY - y;
    distanceLeft = vectorLen(xDiff, yDiff);
    distToMove = Math.ceil(this.getSpeed() / this.SCROLL_FREQUENCY);
    distToMove = Math.min(distToMove, distanceLeft);
    xMove = Math.round(xDiff * distToMove / distanceLeft);
    yMove = Math.round(yDiff * distToMove / distanceLeft);
    if (vectorLen(yDiff, xDiff) > 10) {
      this.moveContent(xMove, yMove);
      return this.distanceMoved += distToMove;
    } else if (this.path.length) {
      return this.target = this.path.shift();
    } else {
      this.moveContent(xDiff, yDiff);
      return this.cancel();
    }
  };

  Scroller.prototype.pathLength = function(xy_list) {
    var length, prevPoint, x, y, _i, _len, _ref;
    length = 0;
    prevPoint = this.getCurrentPosition();
    for (_i = 0, _len = xy_list.length; _i < _len; _i++) {
      _ref = xy_list[_i], x = _ref[0], y = _ref[1];
      length += vectorLen(x - prevPoint[0], y - prevPoint[1]);
      prevPoint = [x, y];
    }
    return length;
  };

  Scroller.prototype.getSpeed = function() {
    var downSpeed, pxRemaining, ratio, result, timePassed, upSpeed;
    pxRemaining = Math.abs(Math.max(this.expectedDistance - this.distanceMoved, 0));
    ratio = Math.sqrt(pxRemaining) / Math.sqrt(this.DECEL_DIST);
    downSpeed = ratio * this.SCROLL_PX_PER_SECOND;
    downSpeed = Math.max(Math.min(downSpeed, this.SCROLL_PX_PER_SECOND), this.MIN_SPEED);
    timePassed = (new Date().getTime() - this.startTime) / 1000;
    upSpeed = Math.min(timePassed * this.ACCELERATION, this.SCROLL_PX_PER_SECOND);
    result = Math.min(upSpeed, downSpeed);
    log("using speed", result);
    return result;
  };

  Scroller.prototype.cancel = function() {
    clearInterval(this._timer);
    return this.done = true;
  };

  return Scroller;

})();

TilingCanvas = (function(_super) {

  __extends(TilingCanvas, _super);

  function TilingCanvas() {
    this.setTileElBG = __bind(this.setTileElBG, this);

    this.getDistanceToCenter = __bind(this.getDistanceToCenter, this);

    this.confirmScrollPosition = __bind(this.confirmScrollPosition, this);

    this.makeBottomRoom = __bind(this.makeBottomRoom, this);

    this.makeRightRoom = __bind(this.makeRightRoom, this);

    this.makeTopRoom = __bind(this.makeTopRoom, this);

    this.makeLeftRoom = __bind(this.makeLeftRoom, this);

    this._moveContent = __bind(this._moveContent, this);

    this.moveContentY = __bind(this.moveContentY, this);

    this.moveContentX = __bind(this.moveContentX, this);

    this.renderMandatoryTiles = __bind(this.renderMandatoryTiles, this);

    this.getMandatoryTiles = __bind(this.getMandatoryTiles, this);

    this.getTile = __bind(this.getTile, this);

    this.createTile = __bind(this.createTile, this);

    this.getCoords = __bind(this.getCoords, this);

    this.cancelScrolling = __bind(this.cancelScrolling, this);

    this.initPathScroll = __bind(this.initPathScroll, this);

    this.initScrollToCoords = __bind(this.initScrollToCoords, this);

    this.getCenter = __bind(this.getCenter, this);

    this.clearBackground = __bind(this.clearBackground, this);

    this.setBackground = __bind(this.setBackground, this);

    this.moveContentBy = __bind(this.moveContentBy, this);

    this.screenPixelsToCoords = __bind(this.screenPixelsToCoords, this);

    this.resize = __bind(this.resize, this);

    this.isBoxInView = __bind(this.isBoxInView, this);

    this.adjustForExternalScroll = __bind(this.adjustForExternalScroll, this);

    this.addItem = __bind(this.addItem, this);

    this.render = __bind(this.render, this);

    this.initialize = __bind(this.initialize, this);
    return TilingCanvas.__super__.constructor.apply(this, arguments);
  }

  TilingCanvas.prototype.TILE_WIDTH = 1024;

  TilingCanvas.prototype.TILE_HEIGHT = 1024;

  TilingCanvas.prototype.className = 'tilingcanvas-canvas';

  TilingCanvas.prototype.events = {
    'dragstart .tile-bg-layer': function(e) {
      return e.preventDefault();
    },
    'scroll': 'adjustForExternalScroll'
  };

  TilingCanvas.prototype.initialize = function(parentEl) {
    this.parentEl = parentEl;
    this.parentEl = $(this.parentEl);
    this.tiles = {};
    this._pasteHappened = false;
    if (this.DEBUG) {
      this.$el.addClass('debug');
    }
    this._moved = 0;
    this._expectedScrollLeft = this._expectedScrollTop = 0;
    return this;
  };

  TilingCanvas.prototype.render = function() {
    var centerX, centerY, height, width, _ref;
    assert(this.parentEl.css('position') === 'relative');
    this.parentEl.append(this.el);
    width = this.$el.width();
    height = this.$el.height();
    width += width % 2;
    height += height % 2;
    this.width = width;
    this.height = height;
    this.topLeftPixelX = -width / 2;
    this.topLeftPixelY = -height / 2;
    this._initialRender = true;
    this.renderMandatoryTiles();
    this._initialRender = false;
    this.$el.scrollLeft(0);
    this.$el.scrollTop(0);
    this.resize();
    _ref = this.getCenter(), centerX = _ref[0], centerY = _ref[1];
    this.trigger('set-center', centerX, centerY);
    return this;
  };

  TilingCanvas.prototype.addItem = function(pixelX, pixelY, element) {
    var tile, tileX, tileY, _ref;
    if (SCROLLPOS_DEBUG) {
      this.confirmScrollPosition();
    }
    _ref = this.getCoords(pixelX, pixelY), tileX = _ref[0], tileY = _ref[1], pixelX = _ref[2], pixelY = _ref[3];
    tile = this.getTile(tileX, tileY);
    return tile.addItem(pixelX, pixelY, element);
  };

  TilingCanvas.prototype.adjustForExternalScroll = function(e) {
    var centerX, centerY, dX, dY, hasMismatch, _ref;
    hasMismatch = this._expectedScrollLeft !== this.$el.scrollLeft() || this._expectedScrollTop !== this.$el.scrollTop();
    if (hasMismatch) {
      log("*** external scroll detected, paste caused:" + this._pasteHappened, e);
      if (this._pasteHappened) {
        this.$el.scrollLeft(this._expectedScrollLeft);
        this.$el.scrollTop(this._expectedScrollTop);
      } else {
        dX = this._expectedScrollLeft - this.$el.scrollLeft();
        dY = this._expectedScrollTop - this.$el.scrollTop();
        this.topLeftPixelX -= dX;
        this.topLeftPixelY -= dY;
        this._expectedScrollLeft = this.$el.scrollLeft();
        this._expectedScrollTop = this.$el.scrollTop();
        this._moved += Math.abs(dX) + Math.abs(dY);
        assert(_.isNumber(this._moved) && !_.isNaN(this._moved));
        if (this._moved > this.TILE_WIDTH) {
          this.renderMandatoryTiles(dX, dY);
          this._moved = 0;
        }
        _ref = this.getCenter(), centerX = _ref[0], centerY = _ref[1];
        return this.trigger('set-center', centerX, centerY);
      }
    }
  };

  TilingCanvas.prototype.isBoxInView = function(x, y, width, height) {
    var bottomBound, bottomBoxEdge, rightBound, rightBoxEdge;
    rightBoxEdge = x + width;
    bottomBoxEdge = y + height;
    if (rightBoxEdge < this.topLeftPixelX || bottomBoxEdge < this.topLeftPixelY) {
      return false;
    }
    rightBound = this.topLeftPixelX + this.width;
    bottomBound = this.topLeftPixelY + this.height;
    if (x > rightBound || y > bottomBound) {
      return false;
    }
    return true;
  };

  TilingCanvas.prototype.resize = function() {
    var d, hasMismatch, newHeight, newWidth, xOffset, yOffset;
    hasMismatch = this._expectedScrollLeft !== this.$el.scrollLeft() || this._expectedScrollTop !== this.$el.scrollTop();
    if (hasMismatch) {
      log("*** Adjusting for unexpected scroll");
      d = $('<div>').css({
        position: 'absolute',
        height: '1px',
        width: '1px',
        left: this.$el.width() + this._expectedScrollLeft + 1,
        top: this.$el.height() + this._expectedScrollTop + 1
      });
      this.$el.append(d);
      this.$el.scrollLeft(this._expectedScrollLeft);
      this.$el.scrollTop(this._expectedScrollTop);
      if (SCROLLPOS_DEBUG) {
        this.confirmScrollPosition();
      }
      this.renderMandatoryTiles();
      d.remove();
    }
    if (SCROLLPOS_DEBUG) {
      this.confirmScrollPosition();
    }
    newWidth = this.$el.width();
    newHeight = this.$el.height();
    if (newWidth % 2) {
      newWidth += 1;
    }
    if (newHeight % 2) {
      newHeight += 1;
    }
    xOffset = (newWidth - this.width) / 2;
    yOffset = (newHeight - this.height) / 2;
    this.width = newWidth;
    this.height = newHeight;
    this.renderMandatoryTiles();
    this.moveContentBy(xOffset, yOffset);
    if (SCROLLPOS_DEBUG) {
      this.confirmScrollPosition();
    }
    return this.trigger('resize', this.width, this.height);
  };

  TilingCanvas.prototype.screenPixelsToCoords = function(screenX, screenY) {
    return [screenX + this.topLeftPixelX, screenY + this.topLeftPixelY];
  };

  TilingCanvas.prototype.moveContentBy = function(dX, dY) {
    var centerX, centerY, _ref;
    if (SCROLLPOS_DEBUG) {
      this.confirmScrollPosition();
    }
    this._moved += Math.abs(dX) + Math.abs(dY);
    assert(_.isNumber(this._moved) && !_.isNaN(this._moved));
    if (this._moved > this.TILE_WIDTH) {
      this.renderMandatoryTiles(dX, dY);
      this._moved = 0;
    }
    this.moveContentX(dX);
    this.moveContentY(dY);
    _ref = this.getCenter(), centerX = _ref[0], centerY = _ref[1];
    return this.trigger('set-center', centerX, centerY);
  };

  TilingCanvas.prototype.setBackground = function(bgUrl, bgSize) {
    var cssValue, tile, _i, _len, _ref, _results;
    log("setBackground called with", arguments);
    this.clearBackground();
    cssValue = "url('" + bgUrl + "')";
    this.backgroundImage = cssValue;
    this.backgroundSize = bgSize;
    _ref = this.$('.' + Tile.prototype.className);
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      tile = _ref[_i];
      _results.push(this.setTileElBG($(tile)));
    }
    return _results;
  };

  TilingCanvas.prototype.clearBackground = function() {
    this.backgroundFn = null;
    this.backgroundImage = null;
    this.backgroundSize = null;
    this.$('.' + Tile.prototype.className).css('backgroundImage', '');
    return this.$('.tile-bg-layer').remove();
  };

  TilingCanvas.prototype.getCenter = function() {
    return [this.topLeftPixelX + this.width / 2, this.topLeftPixelY + this.height / 2];
  };

  TilingCanvas.prototype.initScrollToCoords = function(x, y) {
    this.cancelScrolling();
    return this._scroller = new Scroller(this.getCenter, this.moveContentBy, [[x, y]]);
  };

  TilingCanvas.prototype.initPathScroll = function(xy_list) {
    this.cancelScrolling();
    return this._scroller = new Scroller(this.getCenter, this.moveContentBy, xy_list, Scroller.prototype.FIRST_OBTUSE);
  };

  TilingCanvas.prototype.cancelScrolling = function() {
    var _ref;
    return (_ref = this._scroller) != null ? _ref.cancel() : void 0;
  };

  TilingCanvas.prototype.getCoords = function(pixelX, pixelY) {
    var tileX, tileY, _ref, _ref1;
    _ref = divMod(pixelX, this.TILE_WIDTH), tileX = _ref[0], pixelX = _ref[1];
    _ref1 = divMod(pixelY, this.TILE_HEIGHT), tileY = _ref1[0], pixelY = _ref1[1];
    return [tileX, tileY, pixelX, pixelY];
  };

  TilingCanvas.prototype.createTile = function(tileX, tileY) {
    var elementCoordX, elementCoordY, ourCoordX, ourCoordY, screenCoordX, screenCoordY, tile;
    tile = new Tile();
    if (!this._initialRender) {
      if (SCROLLPOS_DEBUG) {
        this.confirmScrollPosition();
      }
    }
    ourCoordX = this.TILE_WIDTH * tileX;
    screenCoordX = ourCoordX - this.topLeftPixelX;
    elementCoordX = screenCoordX + (this._initialRender ? 0 : this.$el.scrollLeft());
    ourCoordY = this.TILE_HEIGHT * tileY;
    screenCoordY = ourCoordY - this.topLeftPixelY;
    elementCoordY = screenCoordY + (this._initialRender ? 0 : this.$el.scrollTop());
    tile.$el.css({
      left: elementCoordX,
      top: elementCoordY,
      width: this.TILE_WIDTH,
      height: this.TILE_HEIGHT
    });
    tile.$el.data('tileX', tileX);
    tile.$el.data('tileY', tileY);
    if (this.backgroundImage) {
      this.setTileElBG(tile.$el);
    }
    tile.$el.appendTo(this.el);
    if (CANVAS_DEBUG) {
      tile.render();
    }
    return tile;
  };

  TilingCanvas.prototype.getTile = function(tileX, tileY) {
    var tile, _base, _ref;
    tile = (_ref = this.tiles[tileX]) != null ? _ref[tileY] : void 0;
    if (!tile) {
      tile = this.createTile(tileX, tileY);
      (_base = this.tiles)[tileX] || (_base[tileX] = {});
      this.tiles[tileX][tileY] = tile;
    }
    return tile;
  };

  TilingCanvas.prototype.getMandatoryTiles = function(dX, dY) {
    var maxPixelX, maxPixelY, maxTileX, maxTileY, minPixelX, minPixelY, minTileX, minTileY, _, _ref, _ref1, _ref2;
    _ref = [this.topLeftPixelX, this.topLeftPixelY], minPixelX = _ref[0], minPixelY = _ref[1];
    if (-dX < minPixelX) {
      minPixelX -= dX;
    }
    if (-dY < minPixelY) {
      minPixelY -= dY;
    }
    _ref1 = this.getCoords(minPixelX, minPixelY), minTileX = _ref1[0], minTileY = _ref1[1], _ = _ref1[2], _ = _ref1[3];
    minTileX -= 1;
    minTileY -= 1;
    maxPixelX = minPixelX + this.$el.width();
    maxPixelY = minPixelY + this.$el.height();
    if (-dX > maxPixelX) {
      maxPixelX -= dX;
    }
    if (-dY > maxPixelY) {
      maxPixelY -= dY;
    }
    _ref2 = this.getCoords(maxPixelX, maxPixelY), maxTileX = _ref2[0], maxTileY = _ref2[1], _ = _ref2[2], _ = _ref2[3];
    maxTileX += 1;
    maxTileY += 1;
    return [minTileX, minTileY, maxTileX, maxTileY];
  };

  TilingCanvas.prototype.renderMandatoryTiles = function(dX, dY) {
    var maxTileX, maxTileY, minTileX, minTileY, x, y, _i, _ref, _results;
    if (dX == null) {
      dX = 0;
    }
    if (dY == null) {
      dY = 0;
    }
    _ref = this.getMandatoryTiles(dX, dY), minTileX = _ref[0], minTileY = _ref[1], maxTileX = _ref[2], maxTileY = _ref[3];
    _results = [];
    for (x = _i = minTileX; minTileX <= maxTileX ? _i <= maxTileX : _i >= maxTileX; x = minTileX <= maxTileX ? ++_i : --_i) {
      _results.push((function() {
        var _j, _results1;
        _results1 = [];
        for (y = _j = minTileY; minTileY <= maxTileY ? _j <= maxTileY : _j >= maxTileY; y = minTileY <= maxTileY ? ++_j : --_j) {
          _results1.push(this.getTile(x, y));
        }
        return _results1;
      }).call(this));
    }
    return _results;
  };

  TilingCanvas.prototype.moveContentX = function(dX) {
    this._moveContent('scrollLeft', this.makeLeftRoom, this.makeRightRoom, 'scrollWidth', 'width', dX);
    return this.topLeftPixelX -= dX;
  };

  TilingCanvas.prototype.moveContentY = function(dY) {
    this._moveContent('scrollTop', this.makeTopRoom, this.makeBottomRoom, 'scrollHeight', 'height', dY);
    return this.topLeftPixelY -= dY;
  };

  TilingCanvas.prototype._moveContent = function(scrollAttr, makeNegativeRoom, makePositiveRoom, scrollSizeAttr, sizeAttr, distance) {
    var contentSize, newRoom, newScrollPos, roomToScroll, scrollPos, viewSize;
    scrollPos = this.$el[scrollAttr]();
    newScrollPos = scrollPos - distance;
    if (newScrollPos < 0) {
      newRoom = makeNegativeRoom(-newScrollPos);
      newScrollPos = newScrollPos + newRoom;
    } else {
      contentSize = this.$el.prop(scrollSizeAttr);
      viewSize = this.$el[sizeAttr]();
      roomToScroll = contentSize - viewSize - newScrollPos;
      if (roomToScroll < 0) {
        makePositiveRoom(-roomToScroll);
      }
    }
    if (scrollAttr === 'scrollLeft') {
      this._expectedScrollLeft = newScrollPos;
    } else {
      assert(scrollAttr === 'scrollTop');
      this._expectedScrollTop = newScrollPos;
    }
    return this.$el[scrollAttr](newScrollPos);
  };

  TilingCanvas.prototype.makeLeftRoom = function(numPx) {
    var el, leftOffset, newLeftOffset, newScrollPosition, roomToAdd, scrollPosition, tileSizes, _i, _len, _ref;
    if (SCROLLPOS_DEBUG) {
      this.confirmScrollPosition();
    }
    tileSizes = Math.ceil(numPx / this.TILE_WIDTH);
    roomToAdd = tileSizes * this.TILE_WIDTH;
    _ref = this.$el.children();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      el = _ref[_i];
      el = $(el);
      leftOffset = parseInt(el.css('left'), 10);
      newLeftOffset = leftOffset + roomToAdd;
      el.css('left', newLeftOffset);
    }
    scrollPosition = this.$el.scrollLeft();
    newScrollPosition = scrollPosition + roomToAdd;
    this.$el.scrollLeft(newScrollPosition);
    assert(this.$el.scrollLeft() === newScrollPosition);
    this._expectedScrollLeft = newScrollPosition;
    return roomToAdd;
  };

  TilingCanvas.prototype.makeTopRoom = function(numPx) {
    var el, newScrollPosition, newTopOffset, roomToAdd, scrollPosition, tileSizes, topOffset, _i, _len, _ref;
    if (SCROLLPOS_DEBUG) {
      this.confirmScrollPosition();
    }
    tileSizes = Math.ceil(numPx / this.TILE_HEIGHT);
    roomToAdd = tileSizes * this.TILE_HEIGHT;
    _ref = this.$el.children();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      el = _ref[_i];
      el = $(el);
      topOffset = parseInt(el.css('top'), 10);
      newTopOffset = topOffset + roomToAdd;
      el.css('top', newTopOffset);
    }
    scrollPosition = this.$el.scrollTop();
    newScrollPosition = scrollPosition + roomToAdd;
    this.$el.scrollTop(newScrollPosition);
    assert(this.$el.scrollTop() === newScrollPosition);
    this._expectedScrollTop = newScrollPosition;
    return roomToAdd;
  };

  TilingCanvas.prototype.makeRightRoom = function(numPx) {
    var maxTileX, maxTileY, roomToAdd, tileSizes, _, _ref;
    if (SCROLLPOS_DEBUG) {
      this.confirmScrollPosition();
    }
    tileSizes = Math.ceil(numPx / this.TILE_WIDTH);
    roomToAdd = tileSizes * this.TILE_WIDTH;
    _ref = this.getMandatoryTiles(), _ = _ref[0], _ = _ref[1], maxTileX = _ref[2], maxTileY = _ref[3];
    return this.getTile(maxTileX + tileSizes, maxTileY + tileSizes);
  };

  TilingCanvas.prototype.makeBottomRoom = function(numPx) {
    return this.makeRightRoom(numPx);
  };

  TilingCanvas.prototype.confirmScrollPosition = function() {
    this.adjustForExternalScroll(null);
    assert(this._expectedScrollLeft === this.$el.scrollLeft(), "" + this._expectedScrollLeft + " != " + (this.$el.scrollLeft()));
    return assert(this._expectedScrollTop === this.$el.scrollTop(), "" + this._expectedScrollTop + " != " + (this.$el.scrollTop()));
  };

  TilingCanvas.prototype.getDistanceToCenter = function() {
    var centerX, centerY, _ref;
    _ref = this.getCenter(), centerX = _ref[0], centerY = _ref[1];
    return vectorLen(centerX, centerY);
  };

  TilingCanvas.prototype.setTileElBG = function($tileEl) {
    var bgOffsetX, bgOffsetY, h, positionStyle, tileX, tileY, w, _ref;
    tileX = $tileEl.data('tileX');
    tileY = $tileEl.data('tileY');
    _ref = this.backgroundSize, w = _ref[0], h = _ref[1];
    bgOffsetX = parseInt(w / 2) - divMod(tileX * this.TILE_WIDTH, w)[1];
    bgOffsetY = parseInt(h / 2) - divMod(tileY * this.TILE_HEIGHT, h)[1];
    positionStyle = "" + bgOffsetX + "px " + bgOffsetY + "px";
    return $tileEl.css({
      backgroundImage: this.backgroundImage,
      backgroundPosition: positionStyle
    });
  };

  return TilingCanvas;

})(Backbone.View);
